"""Advanced vulnerability injection system for realistic security testing."""

import random
import re
import json
from typing import Dict, Any, List, Optional, Set, Callable, Pattern
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from abc import ABC, abstractmethod

from src.fuzzer.data_models import TestCase, TestType, Defect, DefectType, DefectSeverity


class VulnerabilityCategory(Enum):
    """Categories of vulnerabilities."""
    INJECTION = "injection"
    BROKEN_AUTH = "broken_authentication"
    SENSITIVE_DATA = "sensitive_data_exposure"
    XXE = "xml_external_entities"
    BROKEN_ACCESS = "broken_access_control"
    SECURITY_MISCONFIG = "security_misconfiguration"
    XSS = "cross_site_scripting"
    INSECURE_DESERIALIZATION = "insecure_deserialization"
    KNOWN_VULNS = "known_vulnerabilities"
    INSUFFICIENT_LOGGING = "insufficient_logging"


class VulnerabilityComplexity(Enum):
    """Complexity levels for vulnerabilities."""
    SIMPLE = "simple"      # Single parameter, obvious trigger
    MODERATE = "moderate"  # Multiple conditions, some obfuscation
    COMPLEX = "complex"    # Multi-step, requires specific sequence
    ADVANCED = "advanced"  # Requires deep understanding, timing


@dataclass
class VulnerabilityPattern:
    """Pattern for detecting vulnerability triggers."""
    name: str
    regex_pattern: Optional[Pattern] = None
    string_patterns: List[str] = field(default_factory=list)
    length_threshold: Optional[int] = None
    custom_checker: Optional[Callable[[str], bool]] = None
    case_sensitive: bool = False


@dataclass
class VulnerabilityRule:
    """Rule defining a vulnerability and its triggers."""
    id: str
    name: str
    category: VulnerabilityCategory
    severity: DefectSeverity
    complexity: VulnerabilityComplexity
    description: str
    
    # Trigger conditions
    target_parameters: List[str] = field(default_factory=list)  # Empty = any parameter
    trigger_patterns: List[VulnerabilityPattern] = field(default_factory=list)
    
    # Activation conditions
    test_types: List[TestType] = field(default_factory=list)  # Empty = any type
    probability: float = 1.0  # Probability of triggering when conditions met
    
    # State and configuration
    active: bool = True
    requires_sequence: bool = False  # Multi-step vulnerability
    sequence_state: Dict[str, Any] = field(default_factory=dict)
    
    # Metadata
    cve_references: List[str] = field(default_factory=list)
    owasp_category: Optional[str] = None
    impact_description: str = ""
    mitigation_advice: str = ""
    created_at: datetime = field(default_factory=datetime.now)


class BaseVulnerabilityDetector(ABC):
    """Abstract base class for vulnerability detectors."""
    
    @abstractmethod
    def detect(self, test_case: TestCase, rule: VulnerabilityRule) -> bool:
        """Detect if test case triggers the vulnerability rule.
        
        Args:
            test_case: Test case to analyze
            rule: Vulnerability rule to check
            
        Returns:
            True if vulnerability is triggered
        """
        pass


class PatternVulnerabilityDetector(BaseVulnerabilityDetector):
    """Detector using pattern matching for vulnerability detection."""
    
    def detect(self, test_case: TestCase, rule: VulnerabilityRule) -> bool:
        """Detect vulnerability using pattern matching.
        
        Args:
            test_case: Test case to analyze
            rule: Vulnerability rule to check
            
        Returns:
            True if vulnerability is triggered
        """
        # Check test type filter
        if rule.test_types and test_case.test_type not in rule.test_types:
            return False
        
        # Check probability
        if random.random() > rule.probability:
            return False
        
        # Get parameters to check
        params_to_check = self._get_parameters_to_check(test_case, rule)
        
        # Check each parameter against patterns
        for param_name, param_value in params_to_check.items():
            if self._check_parameter_patterns(param_value, rule.trigger_patterns):
                return True
        
        return False
    
    def _get_parameters_to_check(self, test_case: TestCase, rule: VulnerabilityRule) -> Dict[str, str]:
        """Get parameters to check based on rule configuration.
        
        Args:
            test_case: Test case to analyze
            rule: Vulnerability rule
            
        Returns:
            Dictionary of parameter names and values to check
        """
        if rule.target_parameters:
            # Check only specified parameters
            return {
                param: str(test_case.parameters.get(param, ""))
                for param in rule.target_parameters
                if param in test_case.parameters
            }
        else:
            # Check all parameters
            return {k: str(v) for k, v in test_case.parameters.items()}
    
    def _check_parameter_patterns(self, param_value: str, patterns: List[VulnerabilityPattern]) -> bool:
        """Check if parameter value matches any vulnerability patterns.
        
        Args:
            param_value: Parameter value to check
            patterns: List of patterns to match against
            
        Returns:
            True if any pattern matches
        """
        for pattern in patterns:
            if self._check_single_pattern(param_value, pattern):
                return True
        return False
    
    def _check_single_pattern(self, value: str, pattern: VulnerabilityPattern) -> bool:
        """Check if value matches a single vulnerability pattern.
        
        Args:
            value: Value to check
            pattern: Pattern to match against
            
        Returns:
            True if pattern matches
        """
        # Check custom checker first
        if pattern.custom_checker and pattern.custom_checker(value):
            return True
        
        # Check length threshold
        if pattern.length_threshold and len(value) > pattern.length_threshold:
            return True
        
        # Check regex pattern
        if pattern.regex_pattern and pattern.regex_pattern.search(value):
            return True
        
        # Check string patterns
        check_value = value if pattern.case_sensitive else value.lower()
        for string_pattern in pattern.string_patterns:
            check_pattern = string_pattern if pattern.case_sensitive else string_pattern.lower()
            if check_pattern in check_value:
                return True
        
        return False


class AdvancedVulnerabilityInjector:
    """Advanced vulnerability injection system with comprehensive security testing."""
    
    def __init__(self):
        """Initialize the vulnerability injector."""
        self.rules: Dict[str, VulnerabilityRule] = {}
        self.detector = PatternVulnerabilityDetector()
        self.triggered_vulnerabilities: List[Dict[str, Any]] = []
        
        # Initialize with default vulnerability rules
        self._initialize_default_rules()
    
    def add_vulnerability_rule(self, rule: VulnerabilityRule) -> None:
        """Add a vulnerability rule to the injector.
        
        Args:
            rule: Vulnerability rule to add
        """
        self.rules[rule.id] = rule
    
    def remove_vulnerability_rule(self, rule_id: str) -> None:
        """Remove a vulnerability rule.
        
        Args:
            rule_id: ID of rule to remove
        """
        if rule_id in self.rules:
            del self.rules[rule_id]
    
    def activate_rule(self, rule_id: str) -> None:
        """Activate a vulnerability rule.
        
        Args:
            rule_id: ID of rule to activate
        """
        if rule_id in self.rules:
            self.rules[rule_id].active = True
    
    def deactivate_rule(self, rule_id: str) -> None:
        """Deactivate a vulnerability rule.
        
        Args:
            rule_id: ID of rule to deactivate
        """
        if rule_id in self.rules:
            self.rules[rule_id].active = False
    
    def check_vulnerabilities(self, test_case: TestCase) -> List[Defect]:
        """Check test case against all active vulnerability rules.
        
        Args:
            test_case: Test case to check
            
        Returns:
            List of detected vulnerability defects
        """
        defects = []
        
        for rule in self.rules.values():
            if not rule.active:
                continue
            
            if self.detector.detect(test_case, rule):
                defect = self._create_defect_from_rule(test_case, rule)
                defects.append(defect)
                
                # Track triggered vulnerability
                self.triggered_vulnerabilities.append({
                    "rule_id": rule.id,
                    "test_case_id": test_case.id,
                    "timestamp": datetime.now().isoformat(),
                    "severity": rule.severity.value,
                    "category": rule.category.value
                })
        
        return defects
    
    def get_vulnerability_statistics(self) -> Dict[str, Any]:
        """Get statistics about triggered vulnerabilities.
        
        Returns:
            Dictionary with vulnerability statistics
        """
        if not self.triggered_vulnerabilities:
            return {
                "total_triggered": 0,
                "by_severity": {},
                "by_category": {},
                "by_rule": {}
            }
        
        # Count by severity
        by_severity = {}
        for vuln in self.triggered_vulnerabilities:
            severity = vuln["severity"]
            by_severity[severity] = by_severity.get(severity, 0) + 1
        
        # Count by category
        by_category = {}
        for vuln in self.triggered_vulnerabilities:
            category = vuln["category"]
            by_category[category] = by_category.get(category, 0) + 1
        
        # Count by rule
        by_rule = {}
        for vuln in self.triggered_vulnerabilities:
            rule_id = vuln["rule_id"]
            by_rule[rule_id] = by_rule.get(rule_id, 0) + 1
        
        return {
            "total_triggered": len(self.triggered_vulnerabilities),
            "by_severity": by_severity,
            "by_category": by_category,
            "by_rule": by_rule,
            "active_rules": len([r for r in self.rules.values() if r.active]),
            "total_rules": len(self.rules)
        }
    
    def list_rules(self, active_only: bool = False) -> List[Dict[str, Any]]:
        """List all vulnerability rules.
        
        Args:
            active_only: If True, only return active rules
            
        Returns:
            List of rule information dictionaries
        """
        rules_to_list = self.rules.values()
        if active_only:
            rules_to_list = [r for r in rules_to_list if r.active]
        
        return [
            {
                "id": rule.id,
                "name": rule.name,
                "category": rule.category.value,
                "severity": rule.severity.value,
                "complexity": rule.complexity.value,
                "description": rule.description,
                "active": rule.active,
                "target_parameters": rule.target_parameters,
                "owasp_category": rule.owasp_category,
                "cve_references": rule.cve_references
            }
            for rule in rules_to_list
        ]
    
    def _create_defect_from_rule(self, test_case: TestCase, rule: VulnerabilityRule) -> Defect:
        """Create a defect from a triggered vulnerability rule.
        
        Args:
            test_case: Test case that triggered the vulnerability
            rule: Vulnerability rule that was triggered
            
        Returns:
            Defect object representing the vulnerability
        """
        # Determine location based on target parameters
        location = None
        if rule.target_parameters:
            # Find which parameter triggered the vulnerability
            for param in rule.target_parameters:
                if param in test_case.parameters:
                    location = f"parameter: {param}"
                    break
        
        return Defect(
            id=f"vuln_{rule.id}_{test_case.id}",
            type=DefectType.SECURITY,
            severity=rule.severity,
            description=f"{rule.name}: {rule.description}",
            trigger_test_case=test_case.id,
            location=location,
            impact_assessment=rule.impact_description or f"{rule.category.value} vulnerability detected"
        )
    
    def _initialize_default_rules(self) -> None:
        """Initialize default vulnerability rules."""
        
        # SQL Injection Rules
        sql_injection_patterns = [
            VulnerabilityPattern(
                name="sql_keywords",
                string_patterns=["'", "DROP", "SELECT", "UNION", "INSERT", "DELETE", "UPDATE", "--", ";", "/*", "*/"]
            ),
            VulnerabilityPattern(
                name="sql_injection_classic",
                regex_pattern=re.compile(r"('.*(OR|AND).*'.*=.*')|('.*;\s*(DROP|DELETE|INSERT|UPDATE))", re.IGNORECASE)
            ),
            VulnerabilityPattern(
                name="sql_comment_injection",
                string_patterns=["--", "/*", "*/", "#"]
            )
        ]
        
        self.add_vulnerability_rule(VulnerabilityRule(
            id="sql_injection_basic",
            name="SQL Injection",
            category=VulnerabilityCategory.INJECTION,
            severity=DefectSeverity.CRITICAL,
            complexity=VulnerabilityComplexity.SIMPLE,
            description="Basic SQL injection vulnerability",
            trigger_patterns=sql_injection_patterns,
            test_types=[TestType.SECURITY, TestType.MALFORMED],
            owasp_category="A03:2021 – Injection",
            impact_description="Allows unauthorized database access and manipulation",
            mitigation_advice="Use parameterized queries and input validation"
        ))
        
        # XSS Rules
        xss_patterns = [
            VulnerabilityPattern(
                name="script_tags",
                string_patterns=["<script", "</script>", "javascript:", "onload=", "onerror=", "onclick="]
            ),
            VulnerabilityPattern(
                name="xss_payloads",
                regex_pattern=re.compile(r"<[^>]*on\w+\s*=|javascript:|<script|</script>", re.IGNORECASE)
            )
        ]
        
        self.add_vulnerability_rule(VulnerabilityRule(
            id="xss_reflected",
            name="Reflected XSS",
            category=VulnerabilityCategory.XSS,
            severity=DefectSeverity.HIGH,
            complexity=VulnerabilityComplexity.SIMPLE,
            description="Reflected cross-site scripting vulnerability",
            trigger_patterns=xss_patterns,
            test_types=[TestType.SECURITY],
            owasp_category="A03:2021 – Injection",
            impact_description="Allows execution of malicious scripts in user browsers"
        ))
        
        # Buffer Overflow Rules
        buffer_overflow_patterns = [
            VulnerabilityPattern(
                name="long_input",
                length_threshold=1000
            ),
            VulnerabilityPattern(
                name="format_strings",
                string_patterns=["%s", "%x", "%n", "%p"]
            )
        ]
        
        self.add_vulnerability_rule(VulnerabilityRule(
            id="buffer_overflow",
            name="Buffer Overflow",
            category=VulnerabilityCategory.INJECTION,
            severity=DefectSeverity.CRITICAL,
            complexity=VulnerabilityComplexity.MODERATE,
            description="Buffer overflow vulnerability",
            trigger_patterns=buffer_overflow_patterns,
            test_types=[TestType.SECURITY, TestType.EDGE],
            impact_description="May allow arbitrary code execution"
        ))
        
        # Command Injection Rules
        command_injection_patterns = [
            VulnerabilityPattern(
                name="command_separators",
                string_patterns=[";", "|", "&", "`", "$", "$(", "&&", "||"]
            ),
            VulnerabilityPattern(
                name="dangerous_commands",
                string_patterns=["rm ", "cat ", "ls ", "ps ", "kill ", "wget ", "curl "]
            )
        ]
        
        self.add_vulnerability_rule(VulnerabilityRule(
            id="command_injection",
            name="Command Injection",
            category=VulnerabilityCategory.INJECTION,
            severity=DefectSeverity.CRITICAL,
            complexity=VulnerabilityComplexity.MODERATE,
            description="OS command injection vulnerability",
            trigger_patterns=command_injection_patterns,
            test_types=[TestType.SECURITY],
            owasp_category="A03:2021 – Injection",
            impact_description="Allows execution of arbitrary system commands"
        ))
        
        # Path Traversal Rules
        path_traversal_patterns = [
            VulnerabilityPattern(
                name="directory_traversal",
                string_patterns=["../", "..\\", "/etc/", "/proc/", "/sys/", "C:\\", "\\windows\\"]
            ),
            VulnerabilityPattern(
                name="encoded_traversal",
                string_patterns=["%2e%2e%2f", "%2e%2e\\", "..%2f", "..%5c"]
            )
        ]
        
        self.add_vulnerability_rule(VulnerabilityRule(
            id="path_traversal",
            name="Path Traversal",
            category=VulnerabilityCategory.BROKEN_ACCESS,
            severity=DefectSeverity.HIGH,
            complexity=VulnerabilityComplexity.SIMPLE,
            description="Directory traversal vulnerability",
            trigger_patterns=path_traversal_patterns,
            test_types=[TestType.SECURITY],
            owasp_category="A01:2021 – Broken Access Control",
            impact_description="Allows access to files outside intended directory"
        ))
        
        # Authentication Bypass Rules
        auth_bypass_patterns = [
            VulnerabilityPattern(
                name="auth_bypass_sql",
                string_patterns=["admin' OR '1'='1", "' OR 1=1 --", "admin'--"]
            ),
            VulnerabilityPattern(
                name="auth_bypass_logic",
                string_patterns=["true", "1", "admin", "root", "administrator"]
            )
        ]
        
        self.add_vulnerability_rule(VulnerabilityRule(
            id="auth_bypass",
            name="Authentication Bypass",
            category=VulnerabilityCategory.BROKEN_AUTH,
            severity=DefectSeverity.CRITICAL,
            complexity=VulnerabilityComplexity.MODERATE,
            description="Authentication bypass vulnerability",
            trigger_patterns=auth_bypass_patterns,
            target_parameters=["username", "user", "login", "admin", "password"],
            test_types=[TestType.SECURITY],
            owasp_category="A07:2021 – Identification and Authentication Failures",
            impact_description="Allows unauthorized access to protected resources"
        ))
        
        # LDAP Injection Rules
        ldap_injection_patterns = [
            VulnerabilityPattern(
                name="ldap_metacharacters",
                string_patterns=["*", "(", ")", "\\", "/", "+", "<", ">", ";", "\"", "="]
            ),
            VulnerabilityPattern(
                name="ldap_injection",
                regex_pattern=re.compile(r"[()\\/*+<>;\"=]", re.IGNORECASE)
            )
        ]
        
        self.add_vulnerability_rule(VulnerabilityRule(
            id="ldap_injection",
            name="LDAP Injection",
            category=VulnerabilityCategory.INJECTION,
            severity=DefectSeverity.HIGH,
            complexity=VulnerabilityComplexity.MODERATE,
            description="LDAP injection vulnerability",
            trigger_patterns=ldap_injection_patterns,
            test_types=[TestType.SECURITY],
            owasp_category="A03:2021 – Injection",
            impact_description="Allows unauthorized LDAP directory access"
        ))
        
        # Initialize advanced vulnerability scenarios
        self._initialize_advanced_scenarios()
        
        # XML Injection Rules
        xml_injection_patterns = [
            VulnerabilityPattern(
                name="xml_entities",
                string_patterns=["<!ENTITY", "<!DOCTYPE", "&xxe;", "SYSTEM", "file://"]
            ),
            VulnerabilityPattern(
                name="xml_external_entity",
                regex_pattern=re.compile(r"<!ENTITY.*SYSTEM|<!DOCTYPE.*\[|&\w+;", re.IGNORECASE)
            )
        ]
        
        self.add_vulnerability_rule(VulnerabilityRule(
            id="xml_injection",
            name="XML External Entity (XXE)",
            category=VulnerabilityCategory.XXE,
            severity=DefectSeverity.HIGH,
            complexity=VulnerabilityComplexity.COMPLEX,
            description="XML external entity injection vulnerability",
            trigger_patterns=xml_injection_patterns,
            test_types=[TestType.SECURITY],
            owasp_category="A05:2021 – Security Misconfiguration",
            impact_description="Allows reading of local files and SSRF attacks"
        ))
        
        # Initialize advanced vulnerability scenarios
        self._initialize_advanced_scenarios()
    
    def _initialize_advanced_scenarios(self) -> None:
        """Initialize advanced vulnerability scenarios and complex attack patterns."""
        # Placeholder advanced rules (kept minimal to avoid AttributeError)
        if "dev_backdoor" not in self.rules:
            self.add_vulnerability_rule(VulnerabilityRule(
                id="dev_backdoor",
                name="Development Backdoor",
                category=VulnerabilityCategory.KNOWN_VULNS,
                severity=DefectSeverity.MEDIUM,
                complexity=VulnerabilityComplexity.MODERATE,
                description="Detects common backdoor markers like TODO_BACKDOOR or DEBUG_KEY",
                trigger_patterns=[
                    VulnerabilityPattern(name="backdoor_marker", string_patterns=["TODO_BACKDOOR", "DEBUG_KEY", "INSECURE_DEV_ONLY"], case_sensitive=False)
                ],
                test_types=[TestType.SECURITY],
                impact_description="May indicate forgotten dev-only access paths",
            ))
